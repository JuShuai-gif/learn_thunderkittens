### æ„æ€ä¸€ä¸ªç¬¦åˆNVIDIA Hopper/Adaæ¶æ„é£æ ¼çš„å¼‚æ­¥æµæ°´çº¿(Asynchronous Pipeline)æ¨¡å‹

æ¨¡æ‹Ÿä¸€ä¸ªå¸¸è§çš„åœºæ™¯ï¼š**ä»å…¨å±€æ˜¾å­˜(Global Memory)å¼‚æ­¥æ¬è¿æ•°æ®åˆ°å…±äº«å†…å­˜(Shared Memory)ï¼ŒåŒæ—¶è¿›è¡Œè®¡ç®—**

### å¼‚æ­¥æµæ°´çº¿ç¤ºä¾‹ï¼šMulti-Stage Async Copyæˆ‘ä»¬å°†ç¼“å†²åŒºåˆ†ä¸º $N$ ä¸ªé˜¶æ®µï¼ˆStagesï¼‰ï¼Œä½¿ç”¨ä½ æä¾›çš„ phasebit æ¥æ ‡è®°æ¯ä¸€å—æ•°æ®çš„â€œå°±ç»ªçŠ¶æ€â€ã€‚

```C++
template<int STAGES>
__global__ void async_pipeline_kernel(float* global_input, float* global_output) {
    // 1. å£°æ˜å…±äº«å†…å­˜ç¼“å†²åŒº (ç¯å½¢ç¼“å†²)
    extern __shared__ float s_data[]; // å‡è®¾æ¯ä¸ª stage å¤§å°ä¸º TILE_SIZE
    
    // 2. åˆå§‹åŒ–çŠ¶æ€å˜é‡
    uint32_t phase_field = 0; // ç”¨äºè·Ÿè¸ªæ¯ä¸ª stage çš„ç›¸ä½
    int write_ring = 0;       // ç”Ÿäº§è€…ç´¢å¼•
    int read_ring = 0;        // æ¶ˆè´¹è€…ç´¢å¼•
    
    // 3. é¢„å¡«æµæ°´çº¿ (Prolog)
    #pragma unroll
    for(int i = 0; i < STAGES - 1; i++) {
        // æäº¤å¼‚æ­¥æ‹·è´æŒ‡ä»¤ (cp.async)
        fetch_async(s_data + write_ring * TILE_SIZE, global_input + i * TILE_SIZE);
        
        // æ›´æ–°ç›¸ä½ï¼šæ ‡è®°è¿™ä¸ª stage å·²ç»â€œè¢«é¢„å®šâ€æˆ–â€œæ­£åœ¨å¡«å……â€
        update_phasebit<0>(phase_field, write_ring);
        write_ring = ring_advance<STAGES>(write_ring);
    }

    // 4. ä¸»å¾ªç¯ (Main Loop)
    for(int step = 0; step < TOTAL_STEPS; step++) {
        
        // --- ç”Ÿäº§è€…éƒ¨åˆ† ---
        // æäº¤å½“å‰æ­¥éª¤çš„å¼‚æ­¥æ‹·è´
        fetch_async(s_data + write_ring * TILE_SIZE, global_input + (step + STAGES - 1) * TILE_SIZE);
        update_phasebit<0>(phase_field, write_ring);
        
        // --- åŒæ­¥ç‚¹ ---
        // ç­‰å¾…ç‰¹å®šçš„å¼‚æ­¥æ‹·è´å®Œæˆ (é€šå¸¸é…åˆæŒ‡ä»¤ wait_group)
        // è¿™é‡Œé€»è¾‘ä¸Šä¼šæ£€æŸ¥ get_phasebit æ¥ç¡®è®¤æ•°æ®æ˜¯å¦å¯ç”¨
        wait_for_stage(read_ring); 

        // --- æ¶ˆè´¹è€…éƒ¨åˆ† ---
        // æ£€æŸ¥ç›¸ä½ï¼šç¡®è®¤ read_ring æŒ‡å‘çš„æ•°æ®ç¡®å®æ˜¯å½“å‰å‘¨æœŸçš„
        if (get_phasebit<0>(phase_field, read_ring) == 1) {
            compute_kernel(s_data + read_ring * TILE_SIZE); // çœŸæ­£å¹²æ´»çš„åœ°æ–¹
        }

        // å®Œæˆæ¶ˆè´¹ï¼Œæ¸…é™¤ç›¸ä½æˆ–ç¿»è½¬è¿›å…¥ä¸‹ä¸€è½®
        update_phasebit<0>(phase_field, read_ring); 
        
        // æ¨è¿›ç´¢å¼•
        write_ring = ring_advance<STAGES>(write_ring);
        read_ring = ring_advance<STAGES>(read_ring);
    }
}
```
å½“ç„¶æƒ³ï¼ä¸ºäº†è®©è¿™ä»½ç¤ºä¾‹ä»£ç æ›´æœ‰å‚è€ƒä»·å€¼ï¼Œæˆ‘ä¸ºä½ æ„æ€äº†ä¸€ä¸ªç¬¦åˆ NVIDIA Hopper/Ada æ¶æ„ é£æ ¼çš„å¼‚æ­¥æµæ°´çº¿ï¼ˆAsynchronous Pipelineï¼‰æ¨¡å‹ã€‚åœ¨è¿™ä¸ªä¾‹å­ä¸­ï¼Œæˆ‘ä»¬æ¨¡æ‹Ÿä¸€ä¸ªå¸¸è§çš„åœºæ™¯ï¼šä»å…¨å±€æ˜¾å­˜ï¼ˆGlobal Memoryï¼‰å¼‚æ­¥æ¬è¿æ•°æ®åˆ°å…±äº«å†…å­˜ï¼ˆShared Memoryï¼‰ï¼ŒåŒæ—¶è¿›è¡Œè®¡ç®—ã€‚ğŸš€ å¼‚æ­¥æµæ°´çº¿ç¤ºä¾‹ï¼šMulti-Stage Async Copyæˆ‘ä»¬å°†ç¼“å†²åŒºåˆ†ä¸º $N$ ä¸ªé˜¶æ®µï¼ˆStagesï¼‰ï¼Œä½¿ç”¨ä½ æä¾›çš„ phasebit æ¥æ ‡è®°æ¯ä¸€å—æ•°æ®çš„â€œå°±ç»ªçŠ¶æ€â€ã€‚C++template<int STAGES>
__global__ void async_pipeline_kernel(float* global_input, float* global_output) {
    // 1. å£°æ˜å…±äº«å†…å­˜ç¼“å†²åŒº (ç¯å½¢ç¼“å†²)
    extern __shared__ float s_data[]; // å‡è®¾æ¯ä¸ª stage å¤§å°ä¸º TILE_SIZE
    
    // 2. åˆå§‹åŒ–çŠ¶æ€å˜é‡
    uint32_t phase_field = 0; // ç”¨äºè·Ÿè¸ªæ¯ä¸ª stage çš„ç›¸ä½
    int write_ring = 0;       // ç”Ÿäº§è€…ç´¢å¼•
    int read_ring = 0;        // æ¶ˆè´¹è€…ç´¢å¼•
    
    // 3. é¢„å¡«æµæ°´çº¿ (Prolog)
    #pragma unroll
    for(int i = 0; i < STAGES - 1; i++) {
        // æäº¤å¼‚æ­¥æ‹·è´æŒ‡ä»¤ (cp.async)
        fetch_async(s_data + write_ring * TILE_SIZE, global_input + i * TILE_SIZE);
        
        // æ›´æ–°ç›¸ä½ï¼šæ ‡è®°è¿™ä¸ª stage å·²ç»â€œè¢«é¢„å®šâ€æˆ–â€œæ­£åœ¨å¡«å……â€
        update_phasebit<0>(phase_field, write_ring);
        write_ring = ring_advance<STAGES>(write_ring);
    }

    // 4. ä¸»å¾ªç¯ (Main Loop)
    for(int step = 0; step < TOTAL_STEPS; step++) {
        
        // --- ç”Ÿäº§è€…éƒ¨åˆ† ---
        // æäº¤å½“å‰æ­¥éª¤çš„å¼‚æ­¥æ‹·è´
        fetch_async(s_data + write_ring * TILE_SIZE, global_input + (step + STAGES - 1) * TILE_SIZE);
        update_phasebit<0>(phase_field, write_ring);
        
        // --- åŒæ­¥ç‚¹ ---
        // ç­‰å¾…ç‰¹å®šçš„å¼‚æ­¥æ‹·è´å®Œæˆ (é€šå¸¸é…åˆæŒ‡ä»¤ wait_group)
        // è¿™é‡Œé€»è¾‘ä¸Šä¼šæ£€æŸ¥ get_phasebit æ¥ç¡®è®¤æ•°æ®æ˜¯å¦å¯ç”¨
        wait_for_stage(read_ring); 

        // --- æ¶ˆè´¹è€…éƒ¨åˆ† ---
        // æ£€æŸ¥ç›¸ä½ï¼šç¡®è®¤ read_ring æŒ‡å‘çš„æ•°æ®ç¡®å®æ˜¯å½“å‰å‘¨æœŸçš„
        if (get_phasebit<0>(phase_field, read_ring) == 1) {
            compute_kernel(s_data + read_ring * TILE_SIZE); // çœŸæ­£å¹²æ´»çš„åœ°æ–¹
        }

        // å®Œæˆæ¶ˆè´¹ï¼Œæ¸…é™¤ç›¸ä½æˆ–ç¿»è½¬è¿›å…¥ä¸‹ä¸€è½®
        update_phasebit<0>(phase_field, read_ring); 
        
        // æ¨è¿›ç´¢å¼•
        write_ring = ring_advance<STAGES>(write_ring);
        read_ring = ring_advance<STAGES>(read_ring);
    }
}
ğŸ’¡ ä¸ºä»€ä¹ˆè¿™æ ·å†™å¾ˆç‰›ï¼Ÿï¼ˆä»£ç è§£æï¼‰
1. **é›¶å¼€é”€çŠ¶æ€åˆ‡æ¢**ï¼šç”±äº update_phasebit ä½¿ç”¨çš„æ˜¯å¼‚æˆ–è¿ç®—ï¼ˆ^=ï¼‰ï¼Œæ¯ä¸€è½®å¾ªç¯æ—¶ï¼ŒåŒä¸€ä¸ª ring_id å¯¹åº”çš„ä½ä¼šåœ¨ 0 å’Œ 1 ä¹‹é—´åˆ‡æ¢ã€‚è¿™æ„å‘³ç€ä½ ä¸éœ€è¦åœ¨æ¯ä¸€è½®ç»“æŸæ—¶æ‰‹åŠ¨æŠŠæ•´ä¸ªæ•°ç»„æ¸…é›¶ï¼Œåªéœ€è¦æ£€æŸ¥è¯¥ä½æ˜¯å¦ä¸é¢„æœŸçš„â€œæœ¬è½®ç›¸ä½â€ä¸€è‡´å³å¯ã€‚
2. **åŒé‡è´¦æœ¬**ï¼ˆhalf å‚æ•°ï¼‰ï¼šåœ¨å¤æ‚çš„æ ¸å‡½æ•°ä¸­ï¼Œä½ å¯èƒ½åŒæ—¶æœ‰ä¸¤ç»„æµæ°´çº¿ã€‚ä¾‹å¦‚ï¼š
- half=0ï¼šè®°å½• **Global -> Shared** çš„æ¬è¿è¿›åº¦ã€‚
- half=1ï¼šè®°å½• **Shared -> Register** çš„æ¬è¿è¿›åº¦ã€‚è¿™æ ·ç”¨ä¸€ä¸ªå¯„å­˜å™¨ uint32_t å°±èƒ½ç®¡ç†ä¸¤å¥—å¹¶è¡Œçš„å¼‚æ­¥é€»è¾‘ã€‚
3. **å¯„å­˜å™¨æ•ˆç‡**ï¼šåœ¨ CUDA ä¸­ï¼Œå¯„å­˜å™¨éå¸¸å®è´µã€‚å¦‚æœä½ ç”¨ä¸€ä¸ª bool ready[16] æ•°ç»„æ¥å­˜çŠ¶æ€ï¼Œä¼šå ç”¨å¤§é‡å¯„å­˜å™¨ç©ºé—´ã€‚è€Œ bitfield æ–¹æ¡ˆåªå ç”¨ 1 ä¸ª å¯„å­˜å™¨ã€‚

åœ¨ Hopper (SM 90) æˆ– Ampere (SM 80) æ¶æ„ä¸­ï¼Œä¼˜åŒ– cp.async çš„ç­‰å¾…é€»è¾‘ï¼Œæ ¸å¿ƒåœ¨äºå‡å°‘åŒæ­¥å¼€é”€ï¼ˆpipeline stallï¼‰å¹¶å®ç°è®¡ç®—ä¸è®¿å­˜çš„æ·±åº¦é‡å ã€‚

ç›®å‰çš„ get_phasebit åªæ˜¯ä¸€ä¸ªè½¯ä»¶å±‚é¢çš„æ ‡è®°ã€‚ä¸ºäº†çœŸæ­£å‘æŒ¥ç¡¬ä»¶æ€§èƒ½ï¼Œæˆ‘ä»¬éœ€è¦é…åˆ CUDA çš„ cp.async æŒ‡ä»¤é›†ï¼ˆå¦‚ asm åŒ…è£…çš„ cp.async.wait_groupï¼‰æ¥ä¼˜åŒ–ã€‚

1. æ ¸å¿ƒä¼˜åŒ–æ€è·¯ï¼šåˆ†çº§ç­‰å¾… (Wait Group Partitioning)
`cp.async` çš„é€»è¾‘æ˜¯ï¼šä½ æäº¤ä¸€æ³¢è¯·æ±‚ï¼Œå®ƒä»¬è¿›å…¥ä¸€ä¸ªâ€œåå°é˜Ÿåˆ—â€ã€‚`wait_group` N çš„æ„æ€æ˜¯ï¼šâ€œç­‰åˆ°é˜Ÿåˆ—ä¸­åªå‰©ä¸‹æœ€è¿‘çš„ `N` ä¸ªè¯·æ±‚è¿˜æ²¡å®Œæˆæ—¶ï¼Œæˆ‘å†ç»§ç»­ã€‚â€æˆ‘ä»¬å°†ä½ çš„ `phasebit` ä¸ç¡¬ä»¶ `wait_group` ç»“åˆï¼š

```C++
template<int STAGES, int TILE_SIZE>
__device__ void optimized_pipeline_loop(float* g_in, float* s_data) {
    uint32_t phase_field = 0;
    int write_ring = 0;
    int read_ring = 0;

    // --- 1. æäº¤å‰ N-1 é˜¶æ®µçš„å¼‚æ­¥æ‹·è´ (Prolog) ---
    #pragma unroll
    for (int i = 0; i < STAGES - 1; i++) {
        // cp.async.cg (ç›´æ¥è·³è¿‡ L1ï¼ŒèŠ‚çœç¼“å­˜)
        kittens::asm_cp_async_tile(s_data + write_ring * TILE_SIZE, g_in + i * TILE_SIZE);
        // æ¯æäº¤ä¸€ä¸ªè¯·æ±‚ï¼Œç¡¬ä»¶è®¡æ•°å™¨ +1
        update_phasebit<0>(phase_field, write_ring);
        write_ring = ring_advance<STAGES>(write_ring);
    }

    // --- 2. ä¸»å¾ªç¯ï¼šè®¡ç®—å½“å‰æ­¥ï¼ŒåŒæ—¶åŠ è½½æœªæ¥æ­¥ ---
    for (int step = 0; step < TOTAL_STEPS; step++) {
        
        // ã€ä¼˜åŒ–ç‚¹ Aã€‘ï¼šæå‰æäº¤ä¸‹ä¸€è½®è¯·æ±‚
        // è¿™æ ·åšæ˜¯ä¸ºäº†è®©æ¬è¿ä»»åŠ¡å°½æ—©è¿›å…¥ç¡¬ä»¶é˜Ÿåˆ—
        int next_load_idx = step + STAGES - 1;
        if (next_load_idx < TOTAL_STEPS) {
            kittens::asm_cp_async_tile(s_data + write_ring * TILE_SIZE, g_in + next_load_idx * TILE_SIZE);
            update_phasebit<0>(phase_field, write_ring);
        }

        // ã€ä¼˜åŒ–ç‚¹ Bã€‘ï¼šé¢—ç²’åº¦ç²¾å‡†çš„ç­‰å¾…
        // æˆ‘ä»¬ä¸ä½¿ç”¨é˜»å¡å…¨å›¢çš„ __syncthreads()ï¼Œè€Œæ˜¯ä½¿ç”¨ wait_group
        // å› ä¸ºé˜Ÿåˆ—é‡Œç°åœ¨æœ‰ STAGES ä¸ªä»»åŠ¡ï¼Œæˆ‘ä»¬åªéœ€è¦æœ€è€çš„é‚£ä¸€ä¸ªå®Œæˆ
        // æ‰€ä»¥ç­‰å¾…ç›´åˆ°å‰©ä¸‹ STAGES-1 ä¸ªä»»åŠ¡ï¼Œå³è¡¨ç¤ºæœ€è€çš„é‚£ä¸ªå·²ç»åˆ°å®¶äº†
        kittens::asm_wait_group<STAGES - 1>(); 
        
        // é…åˆå†…å­˜å±éšœï¼Œç¡®ä¿å…±äº«å†…å­˜å¯¹åç»­çº¿ç¨‹å¯è§ (SMEM Barrier)
        __pipeline_commit(); // æäº¤å½“å‰é˜¶æ®µçš„ä»»åŠ¡ç»„
        __pipeline_wait_prior<STAGES - 1>(); // ç­‰å¾…æœ€æ—§çš„ä¸€ç»„å®Œæˆ

        // æ‰§è¡Œè®¡ç®—
        compute_on_stage(s_data + read_ring * TILE_SIZE);

        // æ›´æ–°ç´¢å¼•
        write_ring = ring_advance<STAGES>(write_ring);
        read_ring = ring_advance<STAGES>(read_ring);
    }
}
```

2. å¼•å…¥ TMA (Hopper æ¶æ„ä¸“å±ä¼˜åŒ–)
å¦‚æœä½ åœ¨ç”¨ H100/H200 (Hopper)ï¼Œ`cp.async` å·²ç»ä¸æ˜¯æœ€å¿«çš„äº†ã€‚ä½ åº”è¯¥ä½¿ç”¨ TMA (Tensor Memory Accelerator)ã€‚

TMA çš„ä¼˜åŠ¿åœ¨äºï¼šå®ƒä¸éœ€è¦çº¿ç¨‹å»è®¡ç®—åœ°å€ï¼Œä¹Ÿä¸éœ€è¦åˆ†æ‰¹æäº¤ï¼Œè€Œæ˜¯ç”±ç¡¬ä»¶å•å…ƒç›´æ¥å®Œæˆâ€œå¼ é‡çº§åˆ«â€çš„æ¬è¿ã€‚é…åˆä½ çš„ phasebitï¼Œé€»è¾‘ä¼šå˜æˆï¼š

- ä½¿ç”¨ `mbarrier` ä»£æ›¿è½¯ä»¶æ£€æŸ¥ï¼šHopper å¼•å…¥äº†ç¡¬ä»¶çº§çš„ `mbarrier` å¯¹è±¡ã€‚
- Arrive/Wait æœºåˆ¶ï¼š
    - çº¿ç¨‹å‘ŠçŸ¥ TMAï¼š`mbarrier.expect_tx(size)`ã€‚
    - TMA æ¬è¿å®Œåè‡ªåŠ¨ï¼š`mbarrier.arrive()`ã€‚
    - è®¡ç®—çº¿ç¨‹åªéœ€è¦ï¼š`mbarrier.wait(phase_bit)`ã€‚

3. é’ˆå¯¹ `get_phasebit` çš„è¿›é˜¶ä¼˜åŒ–
ç›®å‰çš„ `update_phasebit` æ˜¯åœ¨æœ¬åœ°å¯„å­˜å™¨æ›´æ–°ã€‚å¦‚æœæ˜¯å¤šä¸ªçº¿ç¨‹åä½œï¼ˆæ¯”å¦‚ä¸€ä¸ª Warp å†™ï¼Œæ•´ä¸ª Block è¯»ï¼‰ï¼Œä½ éœ€è¦ç¡®ä¿çŠ¶æ€åŒæ­¥ï¼š

- ä½¿ç”¨ `__shared__` å­˜å‚¨ Phaseï¼šå¦‚æœå¤šä¸ª Warp å…±äº«è¿™ä¸ªæµæ°´çº¿ï¼Œ`phase_field` åº”è¯¥æ”¾åœ¨å…±äº«å†…å­˜é‡Œã€‚
- åŸå­æ›´æ–°ï¼šä½¿ç”¨ `atomicXor` ç¡®ä¿å¤šçº¿ç¨‹æ›´æ–°ä¸ä¼šå†²çªï¼ˆè™½ç„¶é€šå¸¸ç”± `Lane 0` è´Ÿè´£å³å¯ï¼‰ã€‚
- å†…å­˜ä¸€è‡´æ€§ï¼šåœ¨ `update_phasebit` ååŠ  `__threadfence_block()`ï¼Œç¡®ä¿å…¶ä»–çº¿ç¨‹èƒ½çœ‹åˆ°è¿™ä¸ªä½çš„å˜åŒ–ã€‚

# å…³äº `cp.async` æŒ‡ä»¤å‘å°„çš„é—®é¢˜
å¯ä»¥å°†è¯¥è¿‡ç¨‹æ‹†è§£ä¸ºä¸‰ä¸ªé˜¶æ®µï¼š**å‘å°„ã€å…¥é˜Ÿã€åå°æ‰§è¡Œ**

### 1. æŒ‡ä»¤å‘å°„ï¼šå¹¶ä¸æ˜¯â€œçœŸçš„åœ¨æ¬è¿â€
å½“ä½ æ‰§è¡Œåˆ° `asm_cp_async_tile` æ—¶ï¼Œå½“å‰çº¿ç¨‹çš„ **ALUï¼ˆç®—æœ¯é€»è¾‘å•å…ƒï¼‰** åªæ˜¯ä¸‹è¾¾äº†ä¸€ä¸ªå‘½ä»¤ã€‚

- **åŠ¨ä½œ**ï¼šçº¿ç¨‹æŠŠæºåœ°å€ï¼ˆGlobal Memï¼‰å’Œç›®çš„åœ°å€ï¼ˆShared Memï¼‰ä¸¢ç»™ GPU å†…éƒ¨ä¸€ä¸ªä¸“é—¨å¤„ç†è®¿å­˜çš„ç¡¬ä»¶å•å…ƒï¼ˆæˆ‘ä»¬å¯ä»¥ç®¡å®ƒå« **DMA å¼•æ“**ï¼‰ã€‚

- **æ¶ˆè€—**ï¼šè¿™æ¡æŒ‡ä»¤åœ¨å‘å°„ç¬é—´éå¸¸å¿«ï¼Œçº¿ç¨‹å‡ ä¹ä¸éœ€è¦ç­‰å¾…ï¼Œå®ƒä¼šç«‹åˆ»æ‰§è¡Œä¸‹ä¸€è¡Œçš„ update_phasebitã€‚

- **Slotï¼ˆæ§½ä½ï¼‰**ï¼šä½ æåˆ°çš„â€œSlotâ€åœ¨ç¡¬ä»¶å±‚é¢å¯¹åº” **In-flight CP.ASYNC** é˜Ÿåˆ—ã€‚å¦‚æœè¿™ä¸ªé˜Ÿåˆ—æ»¡äº†ï¼Œçº¿ç¨‹æ‰ä¼šå¡ä½ï¼ˆStallï¼‰ï¼Œç­‰å¾…é˜Ÿåˆ—é‡Šæ”¾ç©ºé—´ã€‚

### 2. â€œå‘å°„â€ä¸â€œå®Œæˆâ€çš„è§£è€¦
è¿™ä¹Ÿæ˜¯ä¸ºä»€ä¹ˆè¦ç”¨ `update_phasebit` å’Œ `wait_group` çš„åŸå› ï¼š

- **è½¯ä»¶è§†è§’**ï¼šæ‰§è¡Œå®Œè¿™æ®µ `for` å¾ªç¯åï¼Œçº¿ç¨‹è®¤ä¸ºè‡ªå·±å·²ç»â€œå¤„ç†â€äº† `STAGES - 1` å—æ•°æ®ã€‚

- **ç¡¬ä»¶è§†è§’**ï¼šæ•°æ®æ¬è¿å¯èƒ½æ‰åˆšåˆšå¼€å§‹ã€‚æ­¤æ—¶æ•°æ®è¿˜åœ¨ä»æ˜¾å­˜ï¼ˆHBMï¼‰é€šè¿‡äº¤å‰å¼€å…³ï¼ˆCrossbarï¼‰æµå‘å…±äº«å†…å­˜çš„è·¯ä¸Šã€‚

### 3. ä¸ºä»€ä¹ˆè¦åœ¨å¾ªç¯é‡Œå…ˆå‘å°„ STAGES - 1 ä¸ªï¼Ÿ
è¿™æ˜¯ä¸€ç§**å¡«æ»¡æµæ°´çº¿**çš„ç­–ç•¥ï¼ˆPrologï¼‰ï¼š

- å¦‚æœä½ åªå‘å°„ 1 ä¸ªå°±å¼€å§‹ç­‰ï¼Œé‚£ä½ çš„è®¡ç®—å•å…ƒï¼ˆCUDA Coresï¼‰å°±è¦ç­‰è®¿å­˜å•å…ƒï¼ˆDMAï¼‰æ¬å®Œã€‚

- ä½ å‘å°„ `STAGES - 1` ä¸ªï¼Œå°±åƒæ˜¯åœ¨ç®¡é“é‡Œå…ˆå¡è¿›å»äº†å¥½å‡ ä¸ªå¿«é€’ã€‚ç­‰ä¸»å¾ªç¯å¼€å§‹å¤„ç†ç¬¬ 0 ä¸ªå¿«é€’æ—¶ï¼Œç¬¬ 1ã€2ã€3 ä¸ªå¿«é€’å·²ç»åœ¨è·¯ä¸Šäº†ã€‚

- **è®¡ç®—æ©ç›–è®¿å­˜**ï¼šå½“ä½ åœ¨å¤„ç† `read_ring` çš„æ•°æ®æ—¶ï¼Œ`write_ring` æŒ‡å‘çš„ç¡¬ä»¶å•å…ƒæ­£åœ¨åå°æ‹¼å‘½æ¬è¿æœªæ¥çš„æ•°æ®ã€‚è¿™ç§**æ—¶é—´ä¸Šçš„é‡å **æ‰æ˜¯æ€§èƒ½èµ·é£çš„å…³é”®ã€‚

### 4. å…³äº `.cg` (Cache Global) çš„è¡¥å……
ä½ åœ¨ä»£ç æ³¨é‡Šä¸­æåˆ°çš„ `cp.async.cg` éå¸¸ä¸“ä¸šï¼š

- `.ca` (Cache All)ï¼šæ•°æ®ä¼šé¡ºä¾¿å¡«æ»¡ L1 Cacheã€‚

- `.cg` (Cache Global)ï¼šæ•°æ®ç›´æ¥ç»•è¿‡ L1 å­˜å…¥ Shared Memoryã€‚

- **æ”¶ç›Š**ï¼šå› ä¸º Shared Memory æœ¬èº«å°±æ˜¯æˆ‘ä»¬æ§åˆ¶çš„â€œæ˜¾å¼ç¼“å­˜â€ï¼Œç»•è¿‡ L1 å¯ä»¥é˜²æ­¢æ¬è¿çš„å¤§é‡æ•°æ®æŠŠ L1 é‡ŒåŸæœ¬å­˜ç€çš„é¢‘ç¹è®¿é—®å˜é‡ï¼ˆæ¯”å¦‚æŸäº›ç®—å­çš„æƒé‡å¸¸é‡ï¼‰ç»™é¡¶æ‰ï¼ˆCache Pollutionï¼‰ã€‚

### 5. ç¡¬ä»¶è®¡æ•°å™¨
æ¯æ¬¡ `asm_cp_async_tile` æˆåŠŸå‘å°„ï¼ŒGPU å†…éƒ¨çš„ä¸€ä¸ªéšå¼è®¡æ•°å™¨å°±ä¼šåŠ  1ã€‚ ä¹‹åçš„ `cp.async.wait_group N` æŒ‡ä»¤å°±æ˜¯å‘Šè¯‰ç¡¬ä»¶ï¼šâ€œå»å–æ¯å’–å•¡ä¼‘æ¯ä¸‹ï¼Œç›´åˆ°è¿™ä¸ªè®¡æ•°å™¨å‡å°‘åˆ°åªå‰© `N` ä¸ºæ­¢ï¼ˆå³å‰åºä»»åŠ¡å·²å®Œæˆï¼‰ã€‚â€








